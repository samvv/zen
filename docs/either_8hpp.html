<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.15.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Zen C++ Libraries: include/zen/either.hpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="zen-logo-white.png"/></td>
  <td id="projectalign">
   <div id="projectname">Zen C++ Libraries
   </div>
   <div id="projectbrief">Zero-dependency re-usable components for C++</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.15.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>include</b></li><li class="navelem"><b>zen</b></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">either.hpp File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Encapsulation for computations that may fail.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;utility&gt;</code><br />
<code>#include &quot;zen/config.hpp&quot;</code><br />
<code>#include &quot;zen/formatting.hpp&quot;</code><br />
</div>
<p><a href="either_8hpp_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:either_3C_20L_2C_20R_20_3E" id="r_either_3C_20L_2C_20R_20_3E"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeither.html">either&lt; L, R &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type for computations that may fail.  <a href="classeither.html#details">More...</a><br /></td></tr>
<tr class="memitem:either_3C_20L_2C_20void_20_3E" id="r_either_3C_20L_2C_20void_20_3E"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeither_3_01L_00_01void_01_4.html">either&lt; L, void &gt;</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-define-members" class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:acf8a20d24c0b5dcffb651336b4bdc4d9" id="r_acf8a20d24c0b5dcffb651336b4bdc4d9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acf8a20d24c0b5dcffb651336b4bdc4d9">ZEN_TRY</a>(<a class="el" href="classvalue.html">value</a>)</td></tr>
<tr class="memdesc:acf8a20d24c0b5dcffb651336b4bdc4d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a left-valued immediately so only a right-valued either type remains.  <br /></td></tr>
<tr class="memitem:a7f80c3f3fc41fe522b175a244d010c99" id="r_a7f80c3f3fc41fe522b175a244d010c99"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7f80c3f3fc41fe522b175a244d010c99">ZEN_TRY_DISCARD</a>(expr)</td></tr>
<tr class="memdesc:a7f80c3f3fc41fe522b175a244d010c99"><td class="mdescLeft">&#160;</td><td class="mdescRight">The same as <a class="el" href="#acf8a20d24c0b5dcffb651336b4bdc4d9">ZEN_TRY</a> but the expression is immediately dropped.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-func-members" class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a8b3684b46576eb05b3c3df431bcffb94" id="r_a8b3684b46576eb05b3c3df431bcffb94"><td class="memTemplParams" colspan="2">template&lt;typename L&gt; </td></tr>
<tr class="memitem:a8b3684b46576eb05b3c3df431bcffb94 template"><td class="memItemLeft" align="right" valign="top">left_t&lt; L &amp; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8b3684b46576eb05b3c3df431bcffb94">left</a> (L &amp;<a class="el" href="classvalue.html">value</a>)</td></tr>
<tr class="memitem:ae35cc59c6f0f6c57d6c657d9ba9f8efa" id="r_ae35cc59c6f0f6c57d6c657d9ba9f8efa"><td class="memTemplParams" colspan="2">template&lt;typename L&gt; </td></tr>
<tr class="memitem:ae35cc59c6f0f6c57d6c657d9ba9f8efa template"><td class="memItemLeft" align="right" valign="top">left_t&lt; L &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae35cc59c6f0f6c57d6c657d9ba9f8efa">left</a> (L &amp;&amp;<a class="el" href="classvalue.html">value</a>)</td></tr>
<tr class="memitem:a47aea71e3695a35d51e75e2e2d0d4ac3" id="r_a47aea71e3695a35d51e75e2e2d0d4ac3"><td class="memItemLeft" align="right" valign="top">right_t&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a47aea71e3695a35d51e75e2e2d0d4ac3">right</a> ()</td></tr>
<tr class="memitem:a6e6bcad5f64ad32dfd6e3e080ee849c1" id="r_a6e6bcad5f64ad32dfd6e3e080ee849c1"><td class="memTemplParams" colspan="2">template&lt;typename R&gt; </td></tr>
<tr class="memitem:a6e6bcad5f64ad32dfd6e3e080ee849c1 template"><td class="memItemLeft" align="right" valign="top">right_t&lt; R &amp; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6e6bcad5f64ad32dfd6e3e080ee849c1">right</a> (R &amp;<a class="el" href="classvalue.html">value</a>)</td></tr>
<tr class="memitem:a1242d63b2e4c534344bd2700220e1c1d" id="r_a1242d63b2e4c534344bd2700220e1c1d"><td class="memTemplParams" colspan="2">template&lt;typename R&gt; </td></tr>
<tr class="memitem:a1242d63b2e4c534344bd2700220e1c1d template"><td class="memItemLeft" align="right" valign="top">right_t&lt; R &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1242d63b2e4c534344bd2700220e1c1d">right</a> (R &amp;&amp;<a class="el" href="classvalue.html">value</a>)</td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Encapsulation for computations that may fail. </p>
<p>A common idiom is to use the type defined in this header on functions that can fail, as an alternatve to exception handling. Some hold that this is a good practice for several reasons:</p>
<ul>
<li>Absence of <span class="tt">throw</span>-statements may allow compilers to better reason about your program, possibly resulting in faster code.</li>
<li>Consumers of your API know immediately that a function might fail, and have to deal with it explicitly.</li>
<li>Because the exception is encoded in the type, some bugs can be captured at compile-time that might otherwise be more subtle.</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md0"></a>
Working With Computations That May Fail</h3>
<p>Often, you find yourself interfacing with external systems, such as a network service or the file system. Doing operations on these objects can result in failures, e.g. an <span class="tt">ENOENT</span> returned from a call to <span class="tt">stat()</span>.</p>
<p>In C, it is very common to store the actual result in one of the function's parameters and return an error code, like so:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> read_some(<span class="keyword">const</span> <span class="keywordtype">char</span>* filename, <span class="keywordtype">char</span>* output) {</div>
<div class="line">  <span class="keywordtype">int</span> fd, error;</div>
<div class="line">  fd = open(in, O_RDONLY);</div>
<div class="line">  <span class="keywordflow">if</span> (fd &lt; 0) {</div>
<div class="line">    <span class="keywordflow">return</span> -1;</div>
<div class="line">  }</div>
<div class="line">  error = read(fd, output, 4);</div>
<div class="line">  <span class="keywordflow">if</span> (error &lt; 0) {</div>
<div class="line">    close(fd);</div>
<div class="line">    <span class="keywordflow">return</span> -1;</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p>In C++ another common idiom is returning a <span class="tt">nullptr</span> whenever a heap-allocated object could not be created. These approaches have obvious drawbacks. In the case of returning an error code instead of the result, we have to make sure our variable can be kept as a reference, leading to more code.</p>
<p>The generic solution to this problem is to introduce a new type, called <span class="tt"><a class="el" href="classeither.html" title="A type for computations that may fail.">either</a></span>, that can hold both a result and an error code, without wasting precious memory. This is exactly what <span class="tt">zen::either&lt;L, R&gt;</span> was made for.</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classeither.html">either&lt;int, std::string&gt;</a> writeSome(std::string filename) {</div>
<div class="line">  <span class="keywordtype">int</span> fd = open(in, O_RDONLY);</div>
<div class="line">  <span class="keywordflow">if</span> (fd &lt; 0) {</div>
<div class="line">    <span class="keywordflow">return</span> zen::left(-1)</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordtype">char</span> buf[4];</div>
<div class="line">  read(fd, buf, 4);</div>
<div class="line">  <span class="keywordflow">return</span> zen::right(std::string(output, 4));</div>
<div class="line">}</div>
<div class="ttc" id="aclasseither_html"><div class="ttname"><a href="classeither.html">either</a></div><div class="ttdoc">A type for computations that may fail.</div><div class="ttdef"><b>Definition</b> either.hpp:123</div></div>
</div><!-- fragment --><p>We can further improve upon our code snippet by declaring an <span class="tt">enum</span> that lists all possible errors that might occur. The errors might even be full classes using virtual inheritance; something which we'll see later on.</p>
<div class="fragment"><div class="line"><span class="keyword">enum class</span> Error {</div>
<div class="line">  OpenFailed,</div>
<div class="line">  ReadFailed,</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classeither.html">either&lt;int, std::string&gt;</a> writeSome(std::string filename) {</div>
<div class="line">  <span class="keywordtype">int</span> fd = open(in, O_RDONLY);</div>
<div class="line">  <span class="keywordflow">if</span> (fd &lt; 0) {</div>
<div class="line">    <span class="keywordflow">return</span> zen::left(Error::OpenFailed)</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordtype">char</span> buf[4];</div>
<div class="line">  <span class="keywordflow">if</span> (read(fd, buf, 4) &lt; 0) {</div>
<div class="line">    <span class="keywordflow">return</span> zen::left(Error::ReadFailed)</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> zen::right(std::string(output, 4));</div>
<div class="line">}</div>
</div><!-- fragment --><p>Finally, we encapsulate our error type in a custom <span class="tt">Result</span>-type that will be used thoughout our application:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">using </span>Result = zen::either&lt;Error, T&gt;;</div>
</div><!-- fragment --><p>That's it! You've learned how to write simple C++ code the Zen way! </p>
</div><a name="doc-define-members" id="doc-define-members"></a><h2 id="header-doc-define-members" class="groupheader">Macro Definition Documentation</h2>
<a id="acf8a20d24c0b5dcffb651336b4bdc4d9" name="acf8a20d24c0b5dcffb651336b4bdc4d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf8a20d24c0b5dcffb651336b4bdc4d9">&#9670;&#160;</a></span>ZEN_TRY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ZEN_TRY</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em><a class="el" href="classvalue.html">value</a></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  <span class="keywordflow">if</span> (<a class="code hl_class" href="classvalue.html">value</a>.is_left()) { \</div>
<div class="line">    return ::zen::left(std::move(<a class="code hl_class" href="classvalue.html">value</a>).take_left()); \</div>
<div class="line">  }</div>
<div class="ttc" id="aclassvalue_html"><div class="ttname"><a href="classvalue.html">value</a></div><div class="ttdef"><b>Definition</b> value.hpp:33</div></div>
</div><!-- fragment -->
<p>Return a left-valued immediately so only a right-valued either type remains. </p>
<p>The remaining value can be safely unwrapped.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md1"></a>
Examples</h2>
<div class="fragment"><div class="line">zen::either&lt;std::string, std::vector&lt;char32_t&gt;&gt; decode_utf8_string(<span class="keyword">const</span> std::string_view&amp; str) {</div>
<div class="line">  std::vector&lt;char32_t&gt; out;</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* iter = <span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*<span class="keyword">&gt;</span>(str.data());</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* end = iter + str.size();</div>
<div class="line">  <span class="keywordflow">for</span> (; iter != end;)  {</div>
<div class="line">    <span class="keyword">auto</span> result = decode_utf8_char(iter);</div>
<div class="line">    <a class="code hl_define" href="#acf8a20d24c0b5dcffb651336b4bdc4d9">ZEN_TRY</a>(result);</div>
<div class="line">    out.push_back(*result); <span class="comment">// may now dereference the result</span></div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> zen::right(std::move(out));</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a7f80c3f3fc41fe522b175a244d010c99" name="a7f80c3f3fc41fe522b175a244d010c99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f80c3f3fc41fe522b175a244d010c99">&#9670;&#160;</a></span>ZEN_TRY_DISCARD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ZEN_TRY_DISCARD</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>expr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  { \</div>
<div class="line">    <span class="keyword">auto</span> zen__either__result = (expr); \</div>
<div class="line">    if (zen__either__result.is_left()) { \</div>
<div class="line">      return ::zen::left(std::move(zen__either__result.left())); \</div>
<div class="line">    } \</div>
<div class="line">  }</div>
</div><!-- fragment -->
<p>The same as <a class="el" href="#acf8a20d24c0b5dcffb651336b4bdc4d9">ZEN_TRY</a> but the expression is immediately dropped. </p>

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Function Documentation</h2>
<a id="ae35cc59c6f0f6c57d6c657d9ba9f8efa" name="ae35cc59c6f0f6c57d6c657d9ba9f8efa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae35cc59c6f0f6c57d6c657d9ba9f8efa">&#9670;&#160;</a></span>left() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename L&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">left_t&lt; L &gt; left </td>
          <td>(</td>
          <td class="paramtype">L &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Construct a left-valued either type. The provided value will be moved into the either type.</p>
<p>Usually, this means that a computation has failed and an error should be returned.</p>
<p>In Rust, one would write <span class="tt">Err(value)</span>. </p>

</div>
</div>
<a id="a8b3684b46576eb05b3c3df431bcffb94" name="a8b3684b46576eb05b3c3df431bcffb94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b3684b46576eb05b3c3df431bcffb94">&#9670;&#160;</a></span>left() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename L&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">left_t&lt; L &amp; &gt; left </td>
          <td>(</td>
          <td class="paramtype">L &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Construct a left-valued either type. The provided value will be copied into the either type.</p>
<p>Usually, this means that a computation has failed and an error should be returned.</p>
<p>In Rust, one would write <span class="tt">Err(value)</span>. </p>

</div>
</div>
<a id="a47aea71e3695a35d51e75e2e2d0d4ac3" name="a47aea71e3695a35d51e75e2e2d0d4ac3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47aea71e3695a35d51e75e2e2d0d4ac3">&#9670;&#160;</a></span>right() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">right_t&lt; void &gt; right </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Construct a right-valued either type that has no contents.</p>
<p>Usually, this means that the computation was successful but no particular value was generated during its run.</p>
<p>In Rust, one would return <span class="tt">Ok(())</span>. </p>

</div>
</div>
<a id="a1242d63b2e4c534344bd2700220e1c1d" name="a1242d63b2e4c534344bd2700220e1c1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1242d63b2e4c534344bd2700220e1c1d">&#9670;&#160;</a></span>right() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">right_t&lt; R &gt; right </td>
          <td>(</td>
          <td class="paramtype">R &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Construct a right-valued either type. The provided value will be copied into the either type.</p>
<p>Usually, this means that the computation was successful and generated exactly one value.</p>
<p>In Rust, one would return <span class="tt">Ok(value)</span>. </p>

</div>
</div>
<a id="a6e6bcad5f64ad32dfd6e3e080ee849c1" name="a6e6bcad5f64ad32dfd6e3e080ee849c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e6bcad5f64ad32dfd6e3e080ee849c1">&#9670;&#160;</a></span>right() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">right_t&lt; R &amp; &gt; right </td>
          <td>(</td>
          <td class="paramtype">R &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Construct a right-valued either type. The provided value will be moved into the either type.</p>
<p>Usually, this means that the computation was successful and generated exactly one value.</p>
<p>In Rust, one would return <span class="tt">Ok(value)</span>. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.15.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
